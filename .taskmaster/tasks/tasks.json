{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Build crafting and equipment system",
        "description": "Implement crafting where players use gathered resources to create items and equipment, which improve combat stats and efficiency.",
        "details": "Define Recipe class with required resources, skill level, and output item. Create a CraftingManager to handle recipe validation and item creation. Integrate with inventory system to deduct resources and add crafted items. Equipment items should have stats (e.g., attack, defense) that modify player combat abilities. Pseudo-code: public bool CraftItem(Recipe recipe) { if (HasResources(recipe) && SkillLevelMet(recipe)) { RemoveResources(recipe); AddItem(recipe.Output); return true; } return false; }",
        "testStrategy": "Unit tests for recipe validation, resource deduction, and item creation. Integration test with UI to craft items and verify inventory updates.",
        "priority": "medium",
        "dependencies": [
          "7",
          "5"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "2",
        "title": "Integrate and test full gameplay loop",
        "description": "Assemble all systems into a cohesive whole and test the complete MVP loop from new game to boss defeat and DLC integration.",
        "details": "Create a test scene or sequence that simulates the full player journey: start new game -> select skill -> gather resources -> craft equipment -> combat -> unlock regions -> defeat stage boss -> complete key task -> save and reload -> verify DLC connectivity. Ensure all systems interact correctly and data flows seamlessly. Fix any integration bugs. Pseudo-code: // In an integration test script: StartNewGame(); SelectSkill(\"Mining\"); SimulateTime(3600); // 1 hour. CraftItem(\"Iron Sword\"); EngageCombat(\"Goblin\"); UnlockRegion(\"Forest\"); CompleteTask(\"Defeat Boss\"); SaveGame(); LoadGame(); VerifyDataConsistency();",
        "testStrategy": "End-to-end integration testing of the entire gameplay loop. Verify that the loop is repeatable and all features work together as specified in the PRD.",
        "priority": "high",
        "dependencies": [
          "7",
          "5",
          "6",
          "1",
          "3",
          "8",
          "4",
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "3",
        "title": "Create combat system with automatic battles and loot drops",
        "description": "Develop the combat system where players select monsters or regions for automatic battles, gaining gold and loot drops, with risk/reward mechanics.",
        "details": "Implement a CombatManager that simulates battles based on player stats (from equipment) vs. monster stats. Use a simple turn-based or time-based auto-resolve system. Include loot tables for monsters with drop chances for items and gold. Integrate with activity system for idle combat progression. Pseudo-code: public CombatResult ResolveCombat(Player player, Monster monster) { // Simulate battle, return result with loot. }",
        "testStrategy": "Unit tests for combat resolution and loot drops. Verify that combat outcomes affect player resources and inventory correctly.",
        "priority": "medium",
        "dependencies": [
          "7",
          "6"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "4",
        "title": "Design and integrate map DLC system",
        "description": "Implement the map DLC system as a minimal viable integration, allowing new regions from DLC to be visible, accessible, and interconnected with the main world.",
        "details": "Extend the region system to support DLC regions. Store DLC data separately (e.g., in a 'DLC' folder) and load it if available. Ensure DLC regions can be unlocked and provide resources/recipes that feed back into the main game (e.g., DLC ore used in main-world crafting). Use a modular approach to allow future DLC additions. Pseudo-code: // Load DLC regions from JSON if DLC file exists. // Integrate into region list for unlocking and activities.",
        "testStrategy": "Test DLC loading by adding a mock DLC file and verifying regions appear in-game. Validate that DLC resources are usable in main-world systems like crafting.",
        "priority": "low",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "5",
        "title": "Implement skill system with progression and unlocking",
        "description": "Develop the skill system where players can select skills (e.g., Mining, Crafting, Combat) to gain experience and level up, unlocking higher-tier resources, recipes, and region conditions.",
        "details": "Create a Skill class with properties: Name, Level, Experience, NextLevelXP, UnlockedRecipes, UnlockedRegions. Implement methods to add experience and check for level-ups. When a skill levels up, update unlocked content based on predefined thresholds (e.g., Mining Level 10 unlocks Iron Ore). Integrate with UI for skill selection and progression display. Pseudo-code: public void GainXP(string skillName, float xp) { skill = playerData.Skills[skillName]; skill.Experience += xp; if (skill.Experience >= skill.NextLevelXP) { LevelUp(skill); } }",
        "testStrategy": "Unit tests for XP gain, level-up logic, and unlocking mechanics. Integration test with UI to verify skill progression updates correctly.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "6",
        "title": "Develop idle activity system for gathering and combat",
        "description": "Implement the core idle gameplay loop where players choose an activity (gathering or combat) and gain resources/experience over time, with support for offline progression.",
        "details": "Create an ActivityManager that handles active skill selection and simulates time-based progression. Use Godot's Timer nodes or delta time calculations for real-time updates. For offline gains, calculate elapsed time since last save and apply appropriate yields based on skill levels and activity rates. Store last activity time in player data. Pseudo-code: // On game start: TimeSpan offlineTime = DateTime.Now - playerData.LastSaveTime; resourcesGained = CalculateOfflineYield(offlineTime, activeSkill); // Real-time: timer.Start(1.0f); // Update every second.",
        "testStrategy": "Test real-time progression with in-game timers. Simulate offline scenarios by manipulating save times and verifying calculated yields match expected values.",
        "priority": "high",
        "dependencies": [
          "7",
          "5"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "7",
        "title": "Implement core data models and serialization",
        "description": "Define and implement C# classes for core game data models (e.g., Player, Skill, Resource, Item, Equipment, Region) with JSON serialization for save/load functionality.",
        "details": "Create C# classes in a 'Models' or 'Data' folder. Include properties for player stats, skills (e.g., Mining, Crafting, Combat), resources (e.g., ore, wood), items, equipment, and regions. Implement JSON serialization using System.Text.Json for saving and loading game state. Ensure models support offline progression calculations. Pseudo-code: public class PlayerData { public string Name; public Dictionary<string, Skill> Skills; public List<Item> Inventory; public DateTime LastSaveTime; } // Save: JsonSerializer.Serialize(playerData); // Load: playerData = JsonSerializer.Deserialize<PlayerData>(json);",
        "testStrategy": "Unit tests for serialization/deserialization of each model. Verify data persistence by saving to a file and reloading in a test scene.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "8",
        "title": "Implement region unlocking and progression",
        "description": "Develop the region system where new areas are unlocked based on skill levels, combat achievements, or task conditions, enabling world expansion.",
        "details": "Create a Region class with properties: Name, IsUnlocked, UnlockConditions (e.g., Mining Level 20, Defeat Boss X). Implement a RegionManager to check conditions and unlock regions when met. Unlocked regions should provide access to new resources, monsters, and activities. Integrate with UI for region selection and display. Pseudo-code: public void CheckUnlockConditions() { foreach (var region in regions) { if (!region.IsUnlocked && ConditionsMet(region)) { region.IsUnlocked = true; } } }",
        "testStrategy": "Unit tests for unlock condition validation. Integration test to verify that unlocking a region updates available activities and UI.",
        "priority": "medium",
        "dependencies": [
          "7",
          "5",
          "3"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "9",
        "title": "Develop task/achievement system for key goals",
        "description": "Create a task or achievement system to define key goals (e.g., defeat stage boss, complete critical task) that drive progression and provide rewards.",
        "details": "Define Task class with objectives (e.g., 'Defeat Boss X', 'Craft Item Y'), rewards, and completion status. Implement a TaskManager to track progress and mark tasks as complete when conditions are met. Integrate with other systems (combat, crafting) to update task progress. Use this for the key task reward summary in the gameplay loop. Pseudo-code: public void UpdateTaskProgress(string taskId) { if (CheckObjectiveMet(taskId)) { CompleteTask(taskId); GiveRewards(taskId); } }",
        "testStrategy": "Unit tests for task completion logic. Integration test to verify that completing a task updates game state and provides rewards.",
        "priority": "medium",
        "dependencies": [
          "7",
          "3",
          "8"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "10",
        "title": "Balance and tune game economy and progression",
        "description": "Adjust numerical values for skills, resources, combat, and crafting to ensure a balanced and engaging progression loop, with appropriate offline gains.",
        "details": "Create configuration files (e.g., JSON) for tuning variables like XP rates, resource yields, combat stats, and unlock conditions. Iteratively test and adjust values to achieve a smooth progression from start to boss defeat. Ensure offline gains are reasonable and capped if necessary to prevent exploitation. Pseudo-code: // Load balance data from 'BalanceConfig.json'. // Use in calculations: xpGain = balanceConfig.XPRate * skillMultiplier;",
        "testStrategy": "Playtesting to assess progression pace and difficulty. Use automated tests to verify that balance changes affect game systems as intended.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6",
          "1",
          "3",
          "8"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "11",
        "title": "Implement UI Integration for Core Features",
        "description": "Develop basic UI components to display gathering, crafting, combat, and inventory.",
        "details": "Create UI views using framework (e.g., React, or in-game UI). Components: GatheringPanel (show active resource, progress), CraftingPanel (recipe list, materials), CombatPanel (enemy HP, player HP, status effects), InventoryPanel (item list). Listen to events from backend systems to update UI in real-time. Highlight rare drops as per PRD 4.1.4.",
        "testStrategy": "Manual testing of UI responsiveness and event handling. Unit tests for UI components if using testable framework. Verify rare drop highlights work.",
        "priority": "medium",
        "dependencies": [
          "20",
          "14",
          "25",
          "19"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "12",
        "title": "Final Integration and End-to-End Testing",
        "description": "Combine all systems, run comprehensive tests, and prepare for deployment.",
        "details": "Integrate all modules: gathering, skills, crafting, combat, inventory, UI, persistence. Set up a full game loop. Conduct end-to-end tests: simulate player gathering resources, leveling skills, crafting items, fighting enemies. Check for bugs and performance issues. Optimize as needed. Prepare build for deployment (e.g., web build, executable).",
        "testStrategy": "End-to-end tests covering typical user flows. Load testing for multiple concurrent actions. User acceptance testing with sample scenarios. Fix any integration issues found.",
        "priority": "high",
        "dependencies": [
          "11",
          "22",
          "23"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "13",
        "title": "Create Crafting Skill System",
        "description": "Develop crafting functionality for initial skill (e.g., forging or cooking) with recipe management.",
        "details": "Implement CraftingSkill class similar to GatheringSkill. Define Recipe data model: materialsRequired (array of {itemId, quantity}), product, craftCycleSeconds, expGiven, unlockConditions. Start with one crafting skill as minimal set. Manage EXP and leveling similarly to gathering.",
        "testStrategy": "Unit tests for recipe validation and crafting skill leveling. Test unlock conditions based on skill level or milestones.",
        "priority": "high",
        "dependencies": [
          "21"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "14",
        "title": "Implement Crafting Cycle and Production",
        "description": "Develop the crafting loop: select recipe, check materials, deduct, timer, and produce items.",
        "details": "Create CraftingManager with methods: startCrafting(playerId, recipeId). Check material availability in inventory; if insufficient, return error. Deduct materials. Start timer based on craftCycleSeconds. On completion: add product to inventory, add EXP to crafting skill. Allow cancellation mid-craft? PRD doesn't specify, assume not for simplicity. Emit events for progress and completion.",
        "testStrategy": "Unit tests for material checks and deductions. Integration tests with timers and inventory updates. Validate EXP gain.",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "15",
        "title": "Implement Combat Drop and Victory/Defeat Logic",
        "description": "Add loot drops on victory and handle win/loss conditions with light penalties.",
        "details": "On enemy HP <= 0: victory. Roll drops from enemy's dropTable using weighted random. Add gold and items to player inventory. On player HP <= 0: defeat. Apply light penalty: lose current battle loot (if any) and interrupt combat. Do not simulate offline combat per PRD 4.4.8. Emit events for results.",
        "testStrategy": "Unit tests for drop table randomness and victory/defeat conditions. Test penalty application. Validate no offline combat simulation.",
        "priority": "medium",
        "dependencies": [
          "25"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "16",
        "title": "Project Setup and Core Architecture",
        "description": "Initialize project with basic structure, define core modules, and set up development environment.",
        "details": "Create or validate a Godot 4.5 project with C# (.NET 8). Ensure the layered structure exists: Game.Core (pure C# domain), Game.Godot (Godot scenes/scripts), plus test projects for xUnit and Tests.Godot for GdUnit4. Use NuGet for .NET dependencies and keep external libraries minimal.",
        "testStrategy": "Verify project builds successfully. Test core module imports and basic event system with unit tests. Ensure environment setup is reproducible.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "17",
        "title": "Add Rare Drop System for Gathering",
        "description": "Implement low-probability rare drops during gathering with UI highlight notifications.",
        "details": "Extend gathering cycle to include rare drop checks. Use random number generation against probability (e.g., 1% chance). If triggered, select item from rareDropTable (array of {itemId, weight}). Add rare item to inventory. Emit event for UI to highlight (e.g., 'rareDrop' event with item details). Keep lightweight as per PRD 4.1.4.",
        "testStrategy": "Unit tests for probability logic and drop table selection. Integration tests to ensure UI events are emitted. Mock random for deterministic testing.",
        "priority": "medium",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "18",
        "title": "Implement Gathering Skill System",
        "description": "Develop core gathering functionality for initial skills (e.g., mining, logging) with leveling and experience.",
        "details": "Implement GatheringSkill class extending base Skill. Manage EXP gain per cycle. Level up logic: on EXP threshold, increase level, unlock new resource points per PRD 4.2.1. Start with 2-3 skills as minimal set. Use event system to notify UI of level changes. Store skill data persistently.",
        "testStrategy": "Unit tests for EXP calculation, level-up triggers, and unlocking mechanics. Integration tests with resource points.",
        "priority": "high",
        "dependencies": [
          "21"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "19",
        "title": "Create Inventory Management System",
        "description": "Develop a unified inventory for resources, crafted items, and combat drops.",
        "details": "Implement Inventory class with methods: addItem(itemId, quantity), removeItem(itemId, quantity), getQuantity(itemId). Support stacking. Integrate with gathering, crafting, and combat systems to update inventory on events. Use persistent storage. Emit events for inventory changes.",
        "testStrategy": "Unit tests for inventory operations (add, remove, stack). Integration tests with other systems to ensure consistency. Test edge cases like insufficient items.",
        "priority": "high",
        "dependencies": [
          "20",
          "14",
          "15"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "20",
        "title": "Implement Gathering Cycle and Resource Yield",
        "description": "Develop the core loop for gathering cycles, producing resources and experience periodically.",
        "details": "Implement gathering cycles driven by a tick-based TimeService (autoload) rather than setInterval. On each tick: progress the active gathering activity, add resources to inventory, and add EXP to the related skill. Support pause/resume when switching activities.",
        "testStrategy": "Test cycle timing accuracy with mock timers. Validate resource and EXP increments. Test concurrent gathering prevention.",
        "priority": "high",
        "dependencies": [
          "30"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "21",
        "title": "Define Data Models for Resources and Skills",
        "description": "Create data structures for resource points, skills, and related entities based on PRD specifications.",
        "details": "Define interfaces/classes in code: ResourcePoint with fields: id, name, requiredSkill, requiredLevel, mainProduct, byProduct, baseCycleSeconds, yieldPerCycle, rareDropTable (optional). Skill with fields: id, name, exp, level, unlockedResourcePoints, unlockedRecipes, areaConditions. Use JSON or database for storage. Include fields for future extensions: fatigue, toolQuality, regionRestricted, rareSpawn. Ensure structure supports adding new skills (mining, logging, fishing, farming) and resource points.",
        "testStrategy": "Unit tests to validate data model creation, serialization/deserialization. Test adding new skills and resource points dynamically.",
        "priority": "high",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "22",
        "title": "Add Persistence and Save/Load Functionality",
        "description": "Implement data saving for player progress, skills, inventory, and game state.",
        "details": "Use local storage or a backend database to save game state. Serialize player data: skills (EXP, level), inventory, combat stats, unlocked milestones. Implement save() on key events (e.g., level up, inventory change) and load() on game start. Ensure data integrity and versioning for future updates.",
        "testStrategy": "Unit tests for serialization/deserialization. Integration tests to save and load game state. Verify no data loss on reload.",
        "priority": "medium",
        "dependencies": [
          "18",
          "13",
          "28",
          "19"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "23",
        "title": "Implement Extension Hooks for Future Features",
        "description": "Add placeholder structures for planned extensions like fatigue, tool quality, and recipe drops.",
        "details": "Extend data models with optional fields: fatigue in gathering, toolQuality modifiers, regionRestricted flags, rareSpawn mechanics. Add event hooks for future systems: e.g., onGatheringCycle, check fatigue. For recipe drops, add dropTable to enemies or gathering. Keep implementations minimal, just stubs or configuration options.",
        "testStrategy": "Unit tests to ensure extension fields don't break existing functionality. Verify hooks are callable and configurable.",
        "priority": "low",
        "dependencies": [
          "21",
          "18",
          "13"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "24",
        "title": "Develop Light Strategy Options for Combat",
        "description": "Add entry-level strategy elements like attack styles and damage type weaknesses.",
        "details": "Implement attack styles: steady (normal), fast (lower damage, higher frequency), heavy (higher damage, lower frequency). Add enemy weakness: certain enemies take more damage from specific styles. This is a lightweight addition per PRD 4.4.7. UI to select style before combat. Adjust damage calculations accordingly.",
        "testStrategy": "Unit tests for attack style modifiers and weakness multipliers. Integration tests with combat ticks. Ensure it doesn't complicate core loop.",
        "priority": "medium",
        "dependencies": [
          "25"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "25",
        "title": "Implement Automatic Combat Tick System",
        "description": "Develop the core combat loop with automatic ticks based on attack intervals.",
        "details": "Implement an automatic combat tick system driven by TimeService ticks. Each tick advances combat state (damage, status effects, cooldowns) and emits results events. Do not rely on any engine-specific Update loop in Core logic; keep engine integration in adapters.",
        "testStrategy": "Unit tests for damage calculation and HP reduction. Integration tests with timer loops. Validate combat flow from start to end.",
        "priority": "high",
        "dependencies": [
          "28"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "26",
        "title": "Add Status Effect System for Combat",
        "description": "Implement fixed rules for status effects (strength, weakness, vulnerable, poison) in combat.",
        "details": "Define status effect classes with properties: type, magnitude, duration (in ticks). Apply effects at combat start or via skills (future). Each tick: strength increases damage by X, weakness reduces damage by Y, vulnerable increases received damage by P%, poison deals damage and decays. Use fixed rules as per PRD 4.4.4. Manage effect stacks and expiration.",
        "testStrategy": "Unit tests for each status effect's impact on damage. Test duration and decay mechanics. Integration with combat ticks.",
        "priority": "medium",
        "dependencies": [
          "28",
          "25"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "27",
        "title": "Develop Skill Milestone and Unlock System",
        "description": "Implement milestone triggers at key levels (e.g., 10, 20) with unlocks and notifications.",
        "details": "Define milestone levels in configuration (e.g., [10, 20, ..., max]). On level up, check if new level matches a milestone. If yes, trigger unlocks: new resource points, recipes, area conditions per PRD 4.2.2. Emit event for UI prompt. Store unlocked state persistently.",
        "testStrategy": "Unit tests for milestone detection and unlock logic. Test with various level progressions. Verify events are fired correctly.",
        "priority": "medium",
        "dependencies": [
          "18"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "28",
        "title": "Define Combat Data Models",
        "description": "Create data structures for enemies, player stats, and combat attributes.",
        "details": "Define interfaces: Enemy with id, name, hp, attack, defense, dropTable, skillCycle (optional). PlayerStats with hp, attack, defense, equipment, states. Combat attributes: hit/dodge (optional), shield/block (optional). Status effects: strength, weakness, vulnerable, poison with fixed rules per PRD 4.4.4. Use JSON/database for storage.",
        "testStrategy": "Unit tests for data model creation and validation. Test status effect application logic.",
        "priority": "high",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "29",
        "title": "Implement Global Passive Bonuses from Skills",
        "description": "Add skill synergies that provide passive bonuses like gathering speed or drop rate increases.",
        "details": "Define passive bonuses in skill data: e.g., mining level 5 gives +5% gathering speed. Create a BonusManager to aggregate bonuses from all skills. Apply bonuses to relevant systems: gathering cycle time reduction, drop rate multipliers. Use lightweight implementation as per PRD 4.2.3. Emit events when bonuses change.",
        "testStrategy": "Unit tests for bonus calculation and application. Integration tests with gathering system to verify speed increases. Test multiple skill synergies.",
        "priority": "medium",
        "dependencies": [
          "18",
          "20"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "30",
        "title": "Create Resource Point Management",
        "description": "Implement resource point data and logic for gathering cycles, including start, stop, and switching.",
        "details": "Create ResourcePointManager to handle active gathering sessions. Methods: startGathering(playerId, resourcePointId), stopGathering(playerId), switchGathering(playerId, newResourcePointId). Use timers for cycles: each cycle yields resources and EXP based on baseCycleSeconds and yieldPerCycle. Check skill requirements before starting. Emit events for resource gain.",
        "testStrategy": "Unit tests for start/stop/switch logic. Integration tests with timers and skill checks. Validate cycle timing and yield amounts.",
        "priority": "high",
        "dependencies": [
          "21",
          "18"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "31",
        "title": "Implement quest progression and tracking system",
        "description": "Build system to track active quests, update objectives, and complete quests.",
        "details": "Create QuestManager class with activeQuests list. Methods: startQuest, updateObjective (called from other systems like inventory or combat), completeQuest. On completion, grant rewards (add items, unlock recipes). Save progress in player data. Pseudo-code: class QuestManager { activeQuests: Map<string, QuestProgress>; updateObjective(questId, objectiveIndex, progress): void; }",
        "testStrategy": "Integration tests for objective updates (e.g., collecting items triggers quest progress). Validate reward distribution on completion.",
        "priority": "high",
        "dependencies": [
          "43"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "32",
        "title": "Add DLC resource and recipe integration",
        "description": "Implement linkage where DLC materials can be used in main world crafting and recipes.",
        "details": "Extend crafting system to accept DLC items as ingredients if DLC is enabled. Recipes that use DLC materials should be available only when DLC is enabled. Update recipe validation logic. Pseudo-code: function canCraft(recipe) { return recipe.ingredients.every(ing => hasItem(ing.itemId) && (isDLCEndabled(ing.itemId) || !isDLCItem(ing.itemId))); }",
        "testStrategy": "Test crafting with DLC materials when enabled/disabled. Verify recipes are accessible only with DLC enabled.",
        "priority": "medium",
        "dependencies": [
          "46",
          "45"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "33",
        "title": "Add quest and achievement UI",
        "description": "Implement UI to display active quests, objectives, and unlocked achievements.",
        "details": "Create quest log UI showing active quests with progress bars for objectives. Achievement UI lists unlocked achievements with rewards. Use tabs or separate screens. Update in real-time as quests progress. Pseudo-code: function updateQuestLog() { questManager.activeQuests.forEach(quest => { displayQuest(quest.title, quest.objectivesProgress); }); }",
        "testStrategy": "UI tests to ensure quest and achievement lists update correctly on progression events. Verify display matches backend data.",
        "priority": "low",
        "dependencies": [
          "31",
          "47"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "34",
        "title": "Implement save/load system for player progress",
        "description": "Add persistence for inventory, quests, achievements, region unlocks, and DLC states.",
        "details": "Create a SaveData class encompassing all player state: inventory, quest progress, achievements, region unlocks, enabled DLCs. Serialize to JSON via System.Text.Json and save under Godot user:// (adapter layer). Load on game start and apply version migration if needed.",
        "testStrategy": "Test saving and loading with various game states. Verify data integrity and that loaded game reflects saved state.",
        "priority": "high",
        "dependencies": [
          "41",
          "31",
          "47",
          "37",
          "45"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "35",
        "title": "Design region data structure for world map",
        "description": "Create data model for regions including attached points (gathering, monsters, shops) and unlock rules.",
        "details": "Define Region class with fields: id, name, isUnlocked, unlockConditions (skill level, quest, boss kill), attachedPoints: GatheringPoint[], MonsterPool[], Shop[]. Store in RegionDatabase. Pseudo-code: class Region { id: string; unlockConditions: Condition[]; attachedPoints: AttachedPoint[]; }",
        "testStrategy": "Unit tests for region creation and unlock condition storage. Validate that attached points are correctly associated.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "36",
        "title": "Implement inventory and equipment UI",
        "description": "Build user interface for viewing and managing inventory and equipped items.",
        "details": "Create UI panels for inventory (grid of slots with item icons and quantities) and equipment (slots for each equipment type). Support drag-and-drop or click to equip/unequip. Include tooltips showing item details. Use responsive design. Pseudo-code: function renderInventory() { inventory.slots.forEach(slot => { if (slot.itemId) renderItemIcon(slot.itemId, slot.quantity); }); }",
        "testStrategy": "UI tests for drag-and-drop, equipping items, and tooltip display. Verify updates reflect backend changes.",
        "priority": "low",
        "dependencies": [
          "41",
          "38"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "37",
        "title": "Implement region unlocking logic",
        "description": "Build system to check unlock conditions and unlock regions based on player progress.",
        "details": "Create RegionManager with method checkUnlockConditions(regionId). Evaluate conditions against player data (skill levels, completed quests, boss kills). On unlock, update region's isUnlocked flag and save to player data. Pseudo-code: class RegionManager { unlockRegion(regionId: string): boolean { // check conditions } }",
        "testStrategy": "Integration tests with player data to verify unlocking works for various conditions (skill, quest, boss).",
        "priority": "high",
        "dependencies": [
          "31",
          "35"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "38",
        "title": "Create equipment slots and equipping mechanism",
        "description": "Implement equipment slots (weapon, armor, accessories) and logic to equip items affecting player stats.",
        "details": "Define EquipmentSlots enum: Weapon, Armor, Accessory1, Accessory2, etc. Create EquipmentManager class with slots dictionary. Equip method validates item type matches slot, unequips previous item. On equip/unequip, update player's combat stats (attack, defense, HP). Pseudo-code: class EquipmentManager { slots: Map<EquipmentSlot, string>; equip(itemId: string, slot: EquipmentSlot): void; }",
        "testStrategy": "Unit tests for equipping/unequipping, stat updates, slot validation. Verify that only equipment items can be equipped.",
        "priority": "high",
        "dependencies": [
          "46",
          "41"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "39",
        "title": "Implement region detail page",
        "description": "Create UI page showing gathering points, monster pools, and shops for a selected region.",
        "details": "Detail page lists attached points from region data. For gathering points, show resource types; for monsters, show enemy details; for shops, list items for sale. Include back button to map. Use scrollable lists. Pseudo-code: function showRegionDetails(regionId) { const region = getRegion(regionId); displayGatheringPoints(region.gatheringPoints); displayMonsters(region.monsterPool); }",
        "testStrategy": "UI tests to ensure all attached points are displayed correctly. Verify navigation from map to details works.",
        "priority": "medium",
        "dependencies": [
          "40"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "40",
        "title": "Create world map UI",
        "description": "Implement UI to display regions, their unlock status, and allow navigation to region details.",
        "details": "Build a map view showing regions as nodes. Use colors/icons for unlocked/locked status. On hover/click, show tooltip with unlock conditions. Clicking an unlocked region opens a detail page with attached points. Use Godot Control UI.",
        "testStrategy": "UI tests to verify correct display based on unlock status. Click interactions open correct details.",
        "priority": "medium",
        "dependencies": [
          "35",
          "37"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "41",
        "title": "Implement inventory system with stacking and capacity",
        "description": "Build the player's inventory/backpack system supporting item stacking, categorization, and capacity limits.",
        "details": "Create Inventory class with slots array. Each slot holds item id and quantity. Implement addItem, removeItem, stackItems methods. Support global warehouse with unlimited or capped capacity. Include search and filter by item type. Use dictionary for quick lookups. Pseudo-code: class Inventory { slots: InventorySlot[]; capacity: number; addItem(itemId, quantity): boolean; } class InventorySlot { itemId: string; quantity: number; }",
        "testStrategy": "Test adding/removing items, stacking logic, capacity limits, and search functionality. Edge cases: overstacking, empty slots.",
        "priority": "high",
        "dependencies": [
          "46"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "42",
        "title": "Create DLC task chain integration with main world",
        "description": "Implement quests in main world that guide players to DLC entry and conditions.",
        "details": "Add main world quests that have objectives related to DLC (e.g., 'Unlock DLC region'). These quests should check DLC enablement and progression. On completion, they might unlock DLC content or provide entry items. Pseudo-code: class MainWorldQuest extends Quest { dlcEntryCondition: Condition; }",
        "testStrategy": "Test that main world quests correctly reference DLC and unlock conditions work with DLC enabled/disabled.",
        "priority": "medium",
        "dependencies": [
          "43",
          "31",
          "45"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "43",
        "title": "Design and implement quest data structure",
        "description": "Create the data model for quests including objectives, rewards, and progression tracking.",
        "details": "Define Quest class with fields: id, title, description, objectives (list of Objective), rewards (items, recipes, passives), prerequisiteQuests, isCompleted. Objective types: CollectItem, KillMonster, CraftItem, etc. Store in QuestDatabase. Pseudo-code: class Quest { id: string; objectives: Objective[]; rewards: Reward[]; } class Objective { type: ObjectiveType; targetId: string; requiredAmount: number; }",
        "testStrategy": "Unit tests for quest creation, objective tracking, and reward assignment. Verify that prerequisites are checked.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "44",
        "title": "Design DLC data structure with ID namespace",
        "description": "Create data model for DLCs including new regions, items, recipes, and tasks, with independent ID naming.",
        "details": "Define DLC class with fields: id, name, enabled, content: { regions: Region[], items: Item[], quests: Quest[] }. Use ID prefix like 'DLC1_' for all DLC content to avoid conflicts. Store in DLCDatabase. Pseudo-code: class DLC { id: string; contentPrefix: string; regions: Region[]; }",
        "testStrategy": "Unit tests to verify ID uniqueness and prefix application. Ensure DLC data can be loaded independently.",
        "priority": "medium",
        "dependencies": [
          "46",
          "43",
          "35"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "45",
        "title": "Implement DLC enablement and data compatibility",
        "description": "Add system to enable/disable DLCs, with data preservation and content activation.",
        "details": "Create DLCManager with methods enableDLC(dlcId), disableDLC(dlcId). When enabled, load DLC content into respective databases (ItemDatabase, QuestDatabase, etc.). Save EnabledDLCs list in player save file. Disabled DLCs keep data but content is hidden/ineffective. Pseudo-code: class DLCManager { enabledDLCs: string[]; enableDLC(dlcId) { this.enabledDLCs.push(dlcId); loadContent(dlcId); } }",
        "testStrategy": "Integration tests for enabling/disabling DLCs, verifying content appears/disappears in game. Check save data integrity.",
        "priority": "high",
        "dependencies": [
          "44"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "46",
        "title": "Design and implement core item data structure",
        "description": "Create the foundational data model for all item types (resource, equipment, consumable, quest item, currency) with necessary attributes.",
        "details": "Define Item as a C# class/record (id, name, type, stackable, maxStack, icon, description). Add specific item types for Equipment/Consumable/Resource/Quest/Currency as needed. Store definitions in JSON (Content/) or Godot Resources (.tres) and load via an adapter.",
        "testStrategy": "Unit tests to verify item creation, type assignment, and attribute storage. Validate that equipment items have stats, consumables have cooldown fields.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "47",
        "title": "Create achievement system with milestones",
        "description": "Implement achievements for skill milestones, boss kills, collection, etc., with rewards.",
        "details": "Define Achievement class similar to Quest but with unlock conditions (e.g., skillLevel >= 10, killCount >= 5). Create AchievementManager to track unlocked achievements and check conditions periodically or on events. Rewards are cosmetic or light bonuses. Pseudo-code: class Achievement { id: string; condition: Condition; reward: Reward; }",
        "testStrategy": "Unit tests for condition checking and achievement unlocking. Verify rewards are applied correctly.",
        "priority": "medium",
        "dependencies": [
          "43"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "48",
        "title": "Implement DLC milestone global passives",
        "description": "Add system where completing DLC milestones grants global bonuses (drop rate, craft speed, HP).",
        "details": "Define DLC milestones as special quests or achievements in DLC content. On completion, apply passive bonuses to player stats globally. Store bonuses in player data and apply modifiers to relevant calculations (e.g., dropRate += 0.1). Pseudo-code: onDLCQuestComplete(questId) { if (questId is milestone) { player.addGlobalBonus(quest.reward.bonus); } }",
        "testStrategy": "Integration tests to verify bonuses are applied after milestone completion and affect game mechanics correctly.",
        "priority": "medium",
        "dependencies": [
          "31",
          "45"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "49",
        "title": "Add extensibility hooks for future features",
        "description": "Implement placeholder systems and data fields for planned expansions like durability, sets, daily quests.",
        "details": "Extend Item class with durability field (for equipment). Add setBonus field to EquipmentItem for future set effects. In Quest, add fields for daily/weekly reset. In Region, add fields for events and weather. Keep these unused but structured for easy future implementation. Pseudo-code: class EquipmentItem extends Item { durability: number; setBonus: SetBonus; }",
        "testStrategy": "Unit tests to ensure new fields exist and can be set/get without breaking existing functionality.",
        "priority": "low",
        "dependencies": [
          "46",
          "43",
          "35"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "50",
        "title": "Implement consumable usage with cooldowns",
        "description": "Add functionality for using consumables (food/potions) with cooldown management and carry limits.",
        "details": "Extend ConsumableItem with effect fields (heal amount, buff type). Create ConsumableManager to handle useConsumable method, applying effects to player. Track cooldowns per consumable type using timestamps. Enforce carry limits in inventory. Pseudo-code: class ConsumableManager { useConsumable(itemId: string): void; cooldowns: Map<string, number>; }",
        "testStrategy": "Test consumable effects, cooldown enforcement, and inventory updates. Validate that effects are applied correctly (e.g., HP restored).",
        "priority": "medium",
        "dependencies": [
          "46",
          "41"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "51",
        "title": "Develop save/load system with versioning",
        "description": "Implement automatic and manual saving of game state (skills, inventory, tasks, map unlocks, DLC status) with version tracking for migration.",
        "details": "Use JSON serialization (System.Text.Json) or binary format. Create SaveData class containing all serializable game data plus version string. Implement SaveManager with methods: SaveGame(auto/manual), LoadGame, DeleteSave. Store lastOnlineTime for offline calculation. Handle version migration by checking saved version against current; if mismatch, apply default values for new fields. Pseudo-code: string json = System.Text.Json.JsonSerializer.Serialize(data); var data2 = System.Text.Json.JsonSerializer.Deserialize<SaveData>(json);",
        "testStrategy": "Test saving and loading with sample data, verify version migration adds default values for new skills/items. Check file integrity and error handling.",
        "priority": "high",
        "dependencies": [
          "52"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "52",
        "title": "Implement data models for skills, inventory, and activities",
        "description": "Define classes for skills (level, progress), inventory items, and activities (collecting, crafting, combat) with serializable properties.",
        "details": "Create Skill class with fields: id, name, level, experience, maxLevel. Create Item class: id, name, type, quantity. Create Activity classes: CollectActivity (resourceId, cycleTime, outputRate), CraftActivity (recipeId, craftTime), CombatActivity (enemyId, attackInterval, damage). Use JSON (Content/) or Godot Resources (.tres) for config data. Keep runtime state serializable for save/load.",
        "testStrategy": "Create test scripts to instantiate data models, modify values, and verify serialization works. Test activity update logic with mock TimeService ticks.",
        "priority": "high",
        "dependencies": [
          "64"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "53",
        "title": "Develop crafting activity system",
        "description": "Implement crafting with recipes and crafting cycles, including UI for craft page.",
        "details": "Create Recipe class with required items, output items, and craftTime. CraftActivity manages ongoing crafts, deducting inputs and adding outputs after craftTime. Integrate with TimeService ticks. CraftPage UI lists recipes, shows progress, and allows starting crafts if ingredients are available.\n\nPseudo-code:\npublic class CraftActivity {\n    public Recipe recipe;\n    private float progress;\n    public void OnTick() {\n        progress += TimeService.tickInterval;\n        if (progress >= recipe.craftTime) {\n            CompleteCraft();\n        }\n    }\n    void CompleteCraft() {\n        inventory.Remove(recipe.requiredItems);\n        inventory.Add(recipe.outputItems);\n    }\n}",
        "testStrategy": "Test crafting with sample recipes, verify inventory changes correctly. Validate UI shows progress and blocks insufficient ingredients.",
        "priority": "medium",
        "dependencies": [
          "52",
          "57"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "54",
        "title": "Create offline rewards calculation system",
        "description": "Calculate offline rewards for collecting and crafting activities based on offline time, with configurable cap (e.g., 8-12 hours) and hard cap initially.",
        "details": "On game start, compute offline time as current time minus lastOnlineTime from save. Cap offline time at capHours. For each collect and craft activity, calculate rewards based on output rates and capped time. Do not calculate offline combat per PRD. Add rewards to player inventory. Implement as a method in OfflineManager called after loading save.",
        "testStrategy": "Simulate offline times (e.g., 1 hour, 10 hours) and verify offline rewards calculation matches expected output. Test cap enforcement and no combat offline rewards.",
        "priority": "high",
        "dependencies": [
          "52",
          "51"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "55",
        "title": "Implement profession synergy (WoW elements)",
        "description": "Add profession synergy: gathering professions supply materials and crafting professions provide enhancements/consumables mechanics.",
        "details": "Define professions (e.g., Mining, Herbalism for collecting; Blacksmithing, Alchemy for crafting). Modify collecting activities to sometimes yield bonus materials if player has related profession skill. Crafting recipes can provide buffs or consumables if crafter has high skill. Add UI hints for synergies.\n\nPseudo-code:\npublic class CollectActivity {\n    public void OnCollect() {\n        int baseOutput = outputPerCycle;\n        if (player.HasProfession(\"Mining\") && resourceId == \"Ore\") {\n            baseOutput += 1; // Bonus\n        }\n        inventory.Add(resourceId, baseOutput);\n    }\n}",
        "testStrategy": "Test collecting with/without professions, verify bonus outputs. Test crafting buffs apply correctly.",
        "priority": "low",
        "dependencies": [
          "61",
          "53"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "56",
        "title": "Add UI feedback systems",
        "description": "Implement upgrade prompts, rare drop highlights, combat drop results summary panels, and offline rewards summary panels.",
        "details": "Create a FeedbackManager to handle popups and highlights. On skill upgrade, show a prompt with new level. On rare drop, highlight item in UI with special effect. After combat, display a results summary panel with loot list. On game start after offline, show a panel detailing offline rewards. Implement UI effects using Godot animations/themes and avoid non-Godot UI components.",
        "testStrategy": "Trigger each feedback event (e.g., simulate rare drop), verify UI appears correctly and dismisses. Test offline rewards panel shows correct amounts (GdUnit4 where engine behavior is involved).",
        "priority": "medium",
        "dependencies": [
          "63",
          "61",
          "53",
          "59",
          "54"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "57",
        "title": "Implement pagination system for different game pages",
        "description": "Create UI pages for collecting, crafting, combat, inventory, tasks, map, and settings with navigation.",
        "details": "Implement pagination/navigation for different pages using Godot scenes (e.g., ScreenNavigator) and Control nodes. Ensure page switching is driven by events and does not leak state.",
        "testStrategy": "Test each page opens correctly via navigation, no overlapping UI. Verify page state resets appropriately when switching.",
        "priority": "medium",
        "dependencies": [
          "63"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "58",
        "title": "Implement inventory system with backpack UI",
        "description": "Create inventory management and backpack page to view and manage items.",
        "details": "Create UI panels for inventory (grid of slots with item icons and quantities) and equipment (slots for each equipment type). Support click to equip/unequip and tooltips showing item details. Implement with Godot Control UI.",
        "testStrategy": "Add/remove items via gameplay, verify backpack UI updates correctly. Test edge cases like zero quantity.",
        "priority": "medium",
        "dependencies": [
          "52",
          "57"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "59",
        "title": "Develop combat activity system",
        "description": "Implement combat mechanics with attack intervals, damage resolution, and death determination, including UI for combat page.",
        "details": "Create Enemy class with health, attack damage, attackInterval. CombatActivity handles combat between player and enemy, updating on ticks. On each tick, reduce enemy health by player damage; if enemy health <= 0, award drops and end combat. CombatPage UI shows enemy stats, health bars, and combat log.\n\nPseudo-code:\npublic class CombatActivity {\n    public Enemy enemy;\n    public void OnTick() {\n        enemy.health -= player.damagePerTick;\n        if (enemy.health <= 0) {\n            AwardDrops(enemy.drops);\n            EndCombat();\n        }\n    }\n}",
        "testStrategy": "Simulate combat with mock enemies, verify health decreases correctly and drops are awarded. Test combat start/stop and UI updates.",
        "priority": "medium",
        "dependencies": [
          "52",
          "57"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "60",
        "title": "Implement map system with map page",
        "description": "Create map unlocking and display, including UI for map page.",
        "details": "Implement a map page using Godot Control UI that displays areas and lock states. Unlock areas when requirements are met. Tie this into the task system and region unlock rules.",
        "testStrategy": "Unlock map areas by meeting requirements, verify UI updates correctly. Test locked state persistence.",
        "priority": "low",
        "dependencies": [
          "52",
          "57"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "61",
        "title": "Develop collecting activity system",
        "description": "Implement collecting mechanics with periodic output based on tick system, including UI for collect page.",
        "details": "Extend CollectActivity to integrate with TimeService ticks. On each tick, progress the timer; when cycleTime is reached, add output items to inventory. Implement CollectPage UI with start/stop buttons using Godot Control UI.",
        "testStrategy": "Run game with TimeService, verify items are added at correct intervals. Test start/stop functionality and UI updates.",
        "priority": "medium",
        "dependencies": [
          "52",
          "57"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "62",
        "title": "Create task system with task page",
        "description": "Implement tasks (quests) with objectives and rewards, including UI for task page.",
        "details": "Implement a task page using Godot Control UI that lists tasks with progress indicators and claim reward actions. TaskManager updates task progress on domain events.",
        "testStrategy": "Create test tasks, complete objectives, verify rewards are given and UI updates. Test task completion tracking.",
        "priority": "low",
        "dependencies": [
          "52",
          "57"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "63",
        "title": "Build main dashboard UI",
        "description": "Implement the main interface with skill overview (level/progress), current activity (output rate/remaining time/current goal), and quick switching.",
        "details": "Use Godot Control UI (Control, Label, TextureRect, ProgressBar, Button). Create a MainDashboard scene with sections: SkillPanel (levels/progress), ActivityPanel (current activity/rate/remaining), and QuickSwitchPanel. Bind UI to game state via a C# controller that reads from adapters/Core state.",
        "testStrategy": "Manual UI testing in Godot editor plus GdUnit4 smoke tests for key bindings and button actions.",
        "priority": "medium",
        "dependencies": [
          "64",
          "52"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "64",
        "title": "Set up project structure and core services",
        "description": "Initialize the project with necessary directories, set up TimeService for tick-based progression, and create a basic game state manager.",
        "details": "Ensure the Godot 4.5 project structure is in place (Game.Core, Game.Godot, Tests, Tests.Godot). Implement a tick-based TimeService as a Godot autoload (Node + Timer or _Process-based accumulator) and a GameStateManager that coordinates adapters and Core state.",
        "testStrategy": "Verify TimeService emits ticks at expected intervals (xUnit for pure logic where possible) and add a GdUnit4 smoke test that autoloads initialize in headless mode.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "65",
        "title": "Add rare spawn system",
        "description": "Implement\u5b9a\u65f6/\u6982\u7387\u51fa\u73b0\u7a00\u6709\u8d44\u6e90\u70b9/\u7a00\u6709\u7cbe\u82f1 with unique material drops.",
        "details": "Create RareSpawnManager that spawns rare resources or elites in regions based on timer or probability. When spawned",
        "testStrategy": "",
        "priority": "low",
        "dependencies": [
          "61",
          "59"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "66",
        "title": "Implement GatheringScreen and CraftingScreen UI",
        "description": "Create UI screens for gathering and crafting operations as per PRD 5.3.2c.",
        "details": "GatheringScreen.tscn: display gathering nodes, progress bars for cooldowns. CraftingScreen.tscn: list recipes, material requirements, craft button. Both call Core managers (ResourceManager, CraftingManager) on player input. Update UI via EventBus subscriptions.",
        "testStrategy": "Manual testing: perform gathering and crafting actions, verify UI reflects core state and outputs.",
        "priority": "medium",
        "dependencies": [
          "83",
          "70",
          "82"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "67",
        "title": "Implement core data models (GameState, Skill, Item, etc.)",
        "description": "Define C# classes in Game.Core for core data models: GameState, Skill, Item, Recipe, Enemy, Region, Quest, Achievement, DLCManifest as per PRD 5.3.1 and 5.5.1.",
        "details": "Create classes in Game.Core namespace: GameState with properties like Skills, Inventory, MapUnlocks, Version, EnabledDLCs, LastOnlineTime. Define Skill with ID, Level, Experience. Item with ID, StackSize. Use ID strings with namespace prefixes (Base_, DLC1_). Ensure classes are serializable with [Serializable] attribute for JSON storage.",
        "testStrategy": "Unit tests in a test project to instantiate models, set properties, and verify serialization/deserialization with System.Text.Json.",
        "priority": "high",
        "dependencies": [
          "84"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "68",
        "title": "Implement CombatScreen UI for battle display",
        "description": "Create CombatScreen to show HP, status, and combat controls as per PRD 5.3.2d.",
        "details": "CombatScreen.tscn: display player and enemy HP bars, status effects, attack animations. Buttons: Start Combat (calls CombatManager), Stop. Subscribe to EventBus for combat events (e.g., damage dealt, loot awarded) to update UI.",
        "testStrategy": "Manual testing: start combat, observe UI updates, verify loot display on combat end.",
        "priority": "medium",
        "dependencies": [
          "78",
          "81",
          "82"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "69",
        "title": "Implement MapScreen and offline reward dialog",
        "description": "Create MapScreen for region display and OfflineRewardDialog for offline rewards summary as per PRD 5.3.2g and h.",
        "details": "MapScreen.tscn: world map with regions, lock icons for locked areas. OfflineRewardDialog.tscn: popup on game start showing rewards calculated by TimeService and ActivitySystem. Use EventBus to trigger dialog.",
        "testStrategy": "Manual testing: open MapScreen, verify region states. Simulate offline time, verify reward dialog shows correct amounts.",
        "priority": "low",
        "dependencies": [
          "72",
          "77",
          "82"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "70",
        "title": "Implement CraftingManager and recipe system",
        "description": "Create CraftingManager to handle crafting recipes, material deduction, and product generation as per PRD 5.3.1e.",
        "details": "CraftingManager.cs in Game.Core: load recipes from JSON, validate materials via InventoryManager, deduct items, add products. Add experience to relevant skill. Publish events for crafting completion.",
        "testStrategy": "Unit tests: test recipe validation, material deduction, product addition, and experience gain.",
        "priority": "medium",
        "dependencies": [
          "67",
          "73",
          "74"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "71",
        "title": "Implement InventoryScreen and equipment management",
        "description": "Create InventoryScreen for backpack and equipment management as per PRD 5.3.2e.",
        "details": "InventoryScreen.tscn: grid of item slots, equipment slots. Allow drag-and-drop or click to equip/unequip. Call InventoryManager methods. Update UI on ItemAdded event.",
        "testStrategy": "Manual testing: add items, equip/unequip, verify UI and core state sync.",
        "priority": "low",
        "dependencies": [
          "74",
          "82"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "72",
        "title": "Implement MapManager and region unlocking",
        "description": "Create MapManager to handle regions, unlock conditions, and content attachment as per PRD 5.3.1l.",
        "details": "MapManager.cs in Game.Core: maintains list of Region objects with unlock conditions (e.g., skill level, quest completion). Method UnlockRegion(string regionId) checks conditions and updates GameState. Publishes RegionUnlocked event.",
        "testStrategy": "Unit tests: test unlock conditions, verify event publishing and GameState update.",
        "priority": "low",
        "dependencies": [
          "67",
          "73"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "73",
        "title": "Implement Autoload services: EventBus and RngService",
        "description": "Create EventBus as a global event system and RngService for random number generation with seed support for reproducibility.",
        "details": "In Autoload folder, create EventBus.cs as a singleton using Godot's Autoload. Define events as C# events or delegates, e.g., event Action<Item> ItemAdded. RngService.cs with methods like int Next(int min, int max) using System.Random with optional seed. Register both in Godot project settings as Autoload scripts.",
        "testStrategy": "Manual testing in Godot: verify EventBus instance exists, events can be subscribed and published. Test RngService with fixed seed to ensure reproducible output.",
        "priority": "medium",
        "dependencies": [
          "84"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "74",
        "title": "Implement InventoryManager and item system",
        "description": "Create InventoryManager to handle backpack, bank, stacking, and equipment as per PRD 5.3.1i.",
        "details": "InventoryManager.cs in Game.Core: manage list of Item slots with stacking logic. Methods: AddItem(string itemId, int quantity), RemoveItem, EquipItem. Publish ItemAdded event. Aggregate character attributes from equipped items.",
        "testStrategy": "Unit tests: add/remove items, test stacking, verify events and attribute calculations.",
        "priority": "medium",
        "dependencies": [
          "67",
          "73"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "75",
        "title": "Implement QuestManager and AchievementTracker",
        "description": "Create QuestManager for quest state machine and AchievementTracker for achievement detection as per PRD 5.3.1j and k.",
        "details": "QuestManager.cs: manages quests with states (NotStarted, InProgress, Completed, Rewarded). Subscribes to EventBus events to update quest objectives. AchievementTracker.cs: similar, tracks achievements and marks them complete. Both update GameState.",
        "testStrategy": "Unit tests: simulate event triggers, verify quest/achievement state transitions and GameState updates.",
        "priority": "low",
        "dependencies": [
          "67",
          "73"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "76",
        "title": "Implement SkillScreen UI and activity start",
        "description": "Create SkillScreen UI to display skills and allow starting activities as per PRD 5.3.2b and 5.4.1.",
        "details": "SkillScreen.tscn with list of skills (e.g., using ItemList). On skill selection, show Start Activity button that calls Core's ActivitySystem.StartActivity(skillId). Subscribe to EventBus to update UI on skill changes. Use C# script in Game.Godot.",
        "testStrategy": "Manual testing: open SkillScreen, start activity, verify UI updates and core logic triggers.",
        "priority": "medium",
        "dependencies": [
          "85",
          "82"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "77",
        "title": "Implement TimeService and ActivitySystem core",
        "description": "Create TimeService to track offline time and ActivitySystem to manage activity ticks as per PRD 5.4.3.",
        "details": "TimeService.cs in Autoload: store LastOnlineTime, calculate offline delta on game start. ActivitySystem in Game.Core: class with Tick(float delta) method that iterates through active activities (Gathering, Crafting, Combat) and calls their internal tick logic. Use EventBus to notify activity updates.",
        "testStrategy": "Unit tests for TimeService delta calculation. Integration test: simulate time passage and verify ActivitySystem triggers ticks correctly.",
        "priority": "high",
        "dependencies": [
          "67",
          "73"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "78",
        "title": "Implement CombatManager and DamageCalculator",
        "description": "Create CombatManager for battle state and DamageCalculator for pure damage computation as per PRD 5.3.1f and g.",
        "details": "CombatManager.cs: manages combat state, enemy HP, attack intervals via ActivitySystem ticks. DamageCalculator.cs: static class with method CalculateDamage(attackerStats, defenderStats) returning damage value. Use formulas based on game balance.",
        "testStrategy": "Unit tests for DamageCalculator with various inputs. Integration test: simulate combat tick and verify damage application.",
        "priority": "medium",
        "dependencies": [
          "67",
          "73",
          "77"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "79",
        "title": "Implement DlcManager for DLC content handling",
        "description": "Create DlcManager to enable DLCs, register content, and apply linkage rules as per PRD 5.3.1m and 5.5.4.",
        "details": "DlcManager.cs in Game.Core: loads DLCManifest JSON, registers additional skills, items, recipes, etc., with DLC1_ prefix. Methods: EnableDlc(string dlcId), MergeContent(). Updates GameState.EnabledDLCs.",
        "testStrategy": "Unit tests: enable DLC, verify content is registered and accessible in GameState.",
        "priority": "low",
        "dependencies": [
          "67"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "80",
        "title": "Implement DataStore for local file storage",
        "description": "Create DataStore service to handle saving and loading GameState to/from local files as per PRD 5.2.5.",
        "details": "DataStore.cs in Autoload: implements IDataStore interface. Methods: SaveGame(GameState state) writes to user://save.json using System.Text.Json. LoadGame() reads and deserializes, handles version migration by checking GameState.Version. Use Godot user:// for safe local storage.",
        "testStrategy": "Manual testing in Godot: save and load game, verify data integrity and version migration logic.",
        "priority": "high",
        "dependencies": [
          "67"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "81",
        "title": "Implement LootGenerator and drop system",
        "description": "Create LootGenerator to handle item drops from combat based on loot tables as per PRD 5.3.1h.",
        "details": "LootGenerator.cs in Game.Core: uses RngService with seed for reproducibility. Method GenerateLoot(string enemyId) returns list of Item IDs based on weighted loot tables defined in JSON. Integrate with CombatManager to award loot on combat end.",
        "testStrategy": "Unit tests: verify loot generation matches probabilities with fixed seed, and items are correctly added to inventory.",
        "priority": "medium",
        "dependencies": [
          "67",
          "73",
          "74"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "82",
        "title": "Create main UI scene and navigation",
        "description": "Build MainScene in Godot with UI for new game, continue, and settings as per PRD 5.3.2a.",
        "details": "In Game/Godot, create MainScene.tscn using Control nodes. Add buttons: New Game (calls Core to create new GameState), Continue (loads via DataStore), Settings (opens config). Use Godot's signals to connect buttons to C# scripts in Game.Godot namespace.",
        "testStrategy": "Manual testing in Godot: run scene, click buttons, verify navigation and core calls work without errors.",
        "priority": "medium",
        "dependencies": [
          "84"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "83",
        "title": "Implement GatheringModel and ResourceManager",
        "description": "Create GatheringModel for gathering point data and ResourceManager to handle resource collection as per PRD 5.3.1d.",
        "details": "GatheringModel.cs: defines gathering node with ID, resource yield, cooldown. ResourceManager.cs: manages active gathering activities, validates conditions, and generates resources on tick via ActivitySystem. Use RngService for rare drops.",
        "testStrategy": "Unit tests: simulate gathering tick, verify resource generation and event publishing.",
        "priority": "medium",
        "dependencies": [
          "67",
          "73",
          "77"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "84",
        "title": "Set up Godot project with C# and folder structure",
        "description": "Initialize a Godot 4.x project with C# support and create the layered folder structure as per PRD: Game.Core, Game.Godot, Autoload services, and Content for JSON configs.",
        "details": "Create a new Godot 4.5 project with C# as the scripting language. Set up folders: Game.Core (pure domain), Game.Godot (scenes and UI), Autoload (services), Content (JSON configs). Prefer System.Text.Json for JSON handling and keep external libraries minimal. Use Godot project settings to enable C# and set up the main scene placeholder.",
        "testStrategy": "Verify project loads in Godot editor, C# scripts compile without errors, and folder structure is visible in the FileSystem dock.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "85",
        "title": "Implement SkillManager and experience system",
        "description": "Create SkillManager to handle skill registration, experience gain, and level-ups as per PRD 5.3.1b.",
        "details": "SkillManager.cs in Game.Core: maintains dictionary of Skill instances. Methods: AddExperience(string skillId, int exp), CheckLevelUp(). On level-up, update skill and publish SkillLeveledUp event via EventBus. Integrate with GameState.",
        "testStrategy": "Unit tests: add experience, trigger level-up, verify event is published and GameState is updated.",
        "priority": "medium",
        "dependencies": [
          "67",
          "73"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "86",
        "title": "Integrate and Polish Full Gameplay Flow",
        "description": "Connect all systems, ensure end-to-end gameplay works from startup to exit, and add polish like UI popups for rewards.",
        "details": "Integrate all components: on startup, load GameState, run OfflineCalculator, show popup for offline rewards. During gameplay, ensure UI screens interact with core systems, events drive updates, and quests/map unlock correctly. Implement UI popups for rare drops, skill level-ups, and region unlocks. Test the full chain: e.g., gathering -> item added -> quest update -> UI refresh. Optimize performance and fix bugs. Pseudo-code: void StartGame() { var state = DataStore.Load<GameState>(); var rewards = OfflineCalculator.Calculate(state); if(rewards.HasItems) ShowPopup(rewards); // proceed to gameplay }.",
        "testStrategy": "End-to-end testing of typical scenarios: startup, gathering, combat, quest completion, and exit. Verify all events are handled, UI updates correctly, and data is saved. Use integration tests and playtesting.",
        "priority": "high",
        "dependencies": [
          "95",
          "94",
          "88",
          "87",
          "99",
          "93"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "87",
        "title": "Build UI Screens for Gameplay",
        "description": "Create UI screens for SkillScreen, GatheringScreen, CombatScreen, and other gameplay interfaces.",
        "details": "Design and implement UI screens using a UI framework. SkillScreen shows skill list and allows selection. GatheringScreen displays resource nodes and a 'Start' button; on click, call ActivitySystem.StartGathering(nodeId). CombatScreen shows enemies/regions and 'Start Battle' button; on click, call CombatManager.StartBattle(enemyId, regionId). Include 'Stop' buttons to call ActivitySystem.StopCurrent(). Subscribe to events for real-time updates (e.g., inventory refresh). Pseudo-code: void OnGatheringStartClicked(string nodeId) { ActivitySystem.StartGathering(nodeId); }.",
        "testStrategy": "UI testing to ensure buttons trigger correct core calls. Verify event-driven updates (e.g., item counts refresh). Test screen transitions.",
        "priority": "medium",
        "dependencies": [
          "98"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "88",
        "title": "Create Map and DLC Management",
        "description": "Implement MapManager to handle region unlocking and DLC integration as per the PRD's map DLC instance.",
        "details": "Develop MapManager with methods RegionUnlocked(regionId) and logic to unlock regions based on conditions (e.g., defeating a boss). Store map state in GameState. Integrate DLC content by checking DLCState. Emit RegionUnlocked event. For the map DLC instance, add specific regions or content tied to DLC. Pseudo-code: class MapManager { public void UnlockRegion(string regionId) { if(!unlockedRegions.Contains(regionId)) { unlockedRegions.Add(regionId); EventSystem.Publish(new RegionUnlocked(regionId)); } } }.",
        "testStrategy": "Test region unlocking logic and event emission. Verify map state is saved/loaded. Check DLC integration if specified.",
        "priority": "low",
        "dependencies": [
          "90"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "89",
        "title": "Develop Combat System",
        "description": "Implement CombatManager for battle initialization, tick-based damage calculation, and victory/defeat conditions.",
        "details": "Create CombatManager with StartBattle(enemyId, regionId) that initializes combatants' HP, attack, defense, and statuses. In Tick(), use DamageCalculator to compute damage, update HP, and apply status effects. Check for HP <= 0 to determine win/loss. On victory, call LootGenerator for drops and InventoryManager.AddItem. Emit CombatEnded event.",
        "testStrategy": "Test combat ticks, damage calculations, and HP updates. Verify victory/defeat logic and loot generation. Check event emissions.",
        "priority": "medium",
        "dependencies": [
          "96"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "90",
        "title": "Implement GameState and Save System",
        "description": "Define the GameState structure to store player progress, including skills, inventory, map, DLC, and lastOnlineTime.",
        "details": "Create a GameState class with properties: List<Skill> skills, List<Item> inventory, MapState map, DLCState dlc, DateTime lastOnlineTime, string currentActivityId. Implement auto-save on exit by setting lastOnlineTime = DateTime.Now and calling DataStore.Save. Add manual save option. Use a unique identifier for each save slot. Pseudo-code: class GameState { public DateTime lastOnlineTime; public string currentActivityId; ... }.",
        "testStrategy": "Test saving and loading GameState with various data. Verify lastOnlineTime is correctly set on exit. Check that multiple save slots work independently.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "91",
        "title": "Build Event System and Subscribers",
        "description": "Implement a central event system and set up subscribers for quests, achievements, and UI updates.",
        "details": "Create an EventSystem class with Publish(event) and Subscribe<T>(Action<T>) methods. Set up QuestManager and AchievementTracker to subscribe to events like ItemAdded, SkillLeveledUp, CombatEnded. Update quest/achievement progress accordingly. Also, UI components should subscribe to refresh data (e.g., inventory count, skill progress). Use observer pattern. Pseudo-code: EventSystem.Subscribe<ItemAdded>( (e) => QuestManager.OnItemAdded(e.itemId, e.count) );.",
        "testStrategy": "Unit tests for event publishing and subscription. Verify quest/achievement updates trigger correctly. Test UI refresh on events.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "92",
        "title": "Create Gathering Activity Implementation",
        "description": "Implement gathering logic including resource validation, tick-based production, and reward distribution.",
        "details": "Develop GatheringAction class that handles a specific gathering activity. In Tick(), increment a timer; when cycle completes, call ResourceManager to validate (e.g., level checks) and generate items/exp. Use InventoryManager.AddItem and SkillManager.GainExp. Emit events: ItemAdded, SkillExpChanged, SkillLeveledUp. Pseudo-code: class GatheringAction { public void Tick() { timer += deltaTime; if(timer >= cycleTime) { var rewards = ResourceManager.ValidateAndGenerate(nodeId); // add to inventory/skills } } }.",
        "testStrategy": "Test gathering ticks produce rewards correctly. Validate resource checks. Verify events are emitted and handled by other systems.",
        "priority": "medium",
        "dependencies": [
          "96"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "93",
        "title": "Add Loot and Resource Generation",
        "description": "Implement LootGenerator for combat drops and ResourceManager for gathering validation and rewards.",
        "details": "Create LootGenerator with a method Roll(enemyId) that returns a list of items based on enemy type and RNG. ResourceManager should validate gathering nodes (check player level, unlocks) and generate appropriate resources/exp. For T2, skip capacity checks as per PRD. Use configurable data (e.g., from JSON files) for loot tables and resource definitions. Pseudo-code: class LootGenerator { public List<ItemDrop> Roll(string enemyId) { // use random and loot table } }.",
        "testStrategy": "Test loot generation with mock enemies to ensure drops are within expected ranges. Validate resource generation logic and integration with activities.",
        "priority": "low",
        "dependencies": [
          "92",
          "89"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "94",
        "title": "Implement Quest and Achievement Tracking",
        "description": "Develop QuestManager and AchievementTracker to monitor player actions and mark completions.",
        "details": "Build QuestManager with a list of quests, each having objectives (e.g., 'collect X items', 'reach skill level N'). Subscribe to relevant events and update progress. On completion, mark quest as done and potentially trigger rewards. Similarly, AchievementTracker handles achievements. Emit events for quest completion. Pseudo-code: class QuestManager { public void OnItemAdded(string itemId, int count) { foreach(var quest in quests) { if(quest.ObjectiveType == 'collect' && quest.TargetItem == itemId) { quest.Progress += count; if(quest.Progress >= quest.Required) CompleteQuest(quest); } } } }.",
        "testStrategy": "Test quest progress updates with mock events. Verify completion triggers and rewards. Check integration with event system.",
        "priority": "low",
        "dependencies": [
          "91"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "95",
        "title": "Implement Offline Calculator System",
        "description": "Create OfflineCalculator to compute rewards based on time since lastOnlineTime when the game starts.",
        "details": "Implement OfflineCalculator class with a method CalculateOfflineRewards(GameState state) that uses lastOnlineTime and current time to simulate activities (e.g., gathering, combat) and generate items/exp. Emit OfflineRewardGranted event with rewards. Integrate into startup flow after loading GameState. Pseudo-code: class OfflineCalculator { public OfflineRewards Calculate(GameState state) { var timeDiff = DateTime.Now - state.lastOnlineTime; // simulate ticks } }.",
        "testStrategy": "Unit tests with different time intervals to verify reward calculations. Test event emission and integration with UI for popup.",
        "priority": "medium",
        "dependencies": [
          "90"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "96",
        "title": "Develop Skill and Activity Systems",
        "description": "Implement SkillManager for skill exp/leveling and ActivitySystem for managing player activities like gathering and combat.",
        "details": "Create SkillManager with methods GainExp(skill, exp) and level-up logic. Implement ActivitySystem with StartGathering(nodeId), StartBattle(enemyId, regionId), StopCurrent(), and Tick() method. Store currentActivityId in GameState. Use a timer or game loop for ticks. Pseudo-code: class ActivitySystem { public void StartGathering(string nodeId) { currentActivity = new GatheringActivity(nodeId); } public void Tick() { currentActivity?.Progress(); } }.",
        "testStrategy": "Unit tests for skill exp gain and level-ups. Test activity start/stop and tick progression. Verify currentActivityId is saved.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "97",
        "title": "Implement Inventory Management",
        "description": "Create InventoryManager to handle item addition, removal, and capacity management (T2 may skip capacity).",
        "details": "Build InventoryManager with methods AddItem(itemId, count), RemoveItem(itemId, count), GetItemCount(itemId). Use a dictionary or list to store items. Emit ItemAdded event on changes. For T2, skip capacity limits as per PRD. Pseudo-code: class InventoryManager { private Dictionary<string, int> items; public void AddItem(string itemId, int count) { items[itemId] += count; EventSystem.Publish(new ItemAdded(itemId, count)); } }.",
        "testStrategy": "Unit tests for adding/removing items. Verify event publishing. Test with multiple item types and edge cases.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "98",
        "title": "Build Main Scene and UI Navigation",
        "description": "Create the MainScene with UI for loading save lists, continuing, or starting a new game.",
        "details": "Design MainScene UI with buttons: 'Continue', 'New Game', 'Load Game'. Implement logic to read save slots from DataStore and display them. On selection, load GameState and transition to gameplay scene. Use Godot Control UI.",
        "testStrategy": "UI testing to ensure buttons respond and correct scenes load. Verify save list displays correctly with mock data.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "99",
        "title": "Implement TimeService and Tick Loop",
        "description": "Create TimeService to drive game ticks for activities and offline calculations.",
        "details": "Develop TimeService as a singleton that updates on a fixed interval (e.g., every second). In each tick, call ActivitySystem.Tick() to progress activities. Also, use it for combat ticks and other time-based logic. Integrate with the game loop or use a coroutine/timer. Pseudo-code: class TimeService { private float tickInterval = 1.0f; public void Update() { elapsedTime += deltaTime; if(elapsedTime >= tickInterval) { ActivitySystem.Tick(); CombatManager.Tick?; elapsedTime = 0; } } }.",
        "testStrategy": "Unit tests for tick intervals and activity progression. Verify that ticks correctly drive gathering and combat. Test integration with offline calculator.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "100",
        "title": "Implement testing and CI strategy for DLC",
        "description": "Establish a comprehensive testing plan and continuous integration pipeline for the DLC, covering unit, integration, and functional tests.",
        "details": "Define a testing strategy as per PRD section 8. Create unit tests for each new class (DLCConfig, Material, Recipe, etc.). Write integration tests for area unlocking, recipe crafting, and ability granting. Implement functional tests for full DLC gameplay flow: acquire map token, enter area, collect materials, fight monsters, defeat boss, gain passive, see decorations. Set up CI/CD pipeline (e.g., using Jenkins, GitHub Actions) to run tests automatically on code commits. Include performance and compatibility tests. Document test cases and ensure coverage for edge cases (e.g., DLC disabled scenarios).\n\nPseudo-code:\n// Example test suite\ndescribe('DLC1 Integration', () => {\n  test('Area unlock with token and DLC enabled', () => { ... });\n  test('Crafting with DLC materials', () => { ... });\n});\n\nConfigure CI to run on push to main branch.",
        "testStrategy": "Execute the defined test suite to validate all DLC functionality. Use CI reports to ensure tests pass consistently. Manual testing for visual and gameplay polish.",
        "priority": "medium",
        "dependencies": [
          "108",
          "109",
          "104",
          "101",
          "107",
          "106",
          "102"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "101",
        "title": "Implement DLC1_MapToken acquisition and area unlock logic",
        "description": "Create the quest or task in the main world high-level area that rewards the 'Snowfield Map' (DLC1_MapToken) and handle DLC-based unlock for North_Snowfield.",
        "details": "Design a quest or task in an existing high-level area of the base game that, upon completion, rewards the player with DLC1_MapToken. If DLC is enabled, this token unlocks access to North_Snowfield (e.g., via a new map icon, NPC dialogue, or portal). If DLC is not enabled, the token is treated as a collectible item with no functional use (maybe with a tooltip hinting at DLC). Implement logic to check both token possession and DLC enabled status before allowing entry.\n\nPseudo-code:\nclass Quest {\n  string questId;\n  Reward[] rewards; // includes DLC1_MapToken\n}\n\nOn quest completion: if DLC enabled, unlock North_Snowfield; else, add token to inventory as collectible.",
        "testStrategy": "Test quest completion rewards token correctly. Verify North_Snowfield is accessible only when both token is possessed and DLC is enabled. Test token behavior when DLC is disabled (should be collectible only).",
        "priority": "medium",
        "dependencies": [
          "108",
          "109"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "102",
        "title": "Integrate DLC content with base game systems",
        "description": "Ensure seamless integration of DLC materials, recipes, and abilities with existing base game systems like inventory, crafting, and UI.",
        "details": "Update base game systems to recognize DLC content. Modify inventory system to handle DLC materials (DLC1_IceCrystal, DLC1_FrostHide) with proper icons and descriptions. Update crafting UI to filter or highlight DLC recipes when DLC is enabled. Integrate the 'Frost Blessing' passive into the player's ability UI and ensure it affects global calculations. Handle save/load to persist DLC progress (map token possession, boss defeat, passive ability).",
        "testStrategy": "End-to-end integration testing: verify DLC materials can be collected, stored in inventory, used in crafting. Test UI displays correctly. Test save/load preserves DLC state. Performance test to ensure no degradation with DLC content.",
        "priority": "high",
        "dependencies": [
          "108",
          "104",
          "107"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "103",
        "title": "Optimize and polish DLC content",
        "description": "Refine DLC implementation for performance, balance, and user experience, including bug fixes and tuning.",
        "details": "After initial implementation, optimize DLC content. Balance material drop rates, monster difficulty, and boss fight mechanics. Tune 'Frost Blessing' parameters (X%, Y%) for fair gameplay. Optimize asset loading for North_Snowfield area to prevent performance hits. Fix any bugs identified during testing. Polish UI elements for DLC recipes and materials.",
        "testStrategy": "Performance testing: measure frame rate and load times in North_Snowfield. Balance testing: verify material availability and combat difficulty are appropriate. User acceptance testing with a focus group.",
        "priority": "low",
        "dependencies": [
          "109",
          "104",
          "107",
          "102"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "104",
        "title": "Add new materials and integrate into base game recipes",
        "description": "Implement the new materials DLC1_IceCrystal and DLC1_FrostHide, and create new base game recipes that require these materials.",
        "details": "Extend the game's crafting system to include DLC materials. Add DLC1_IceCrystal as a material for the base forging recipe 'Frost Weapon Enhancement', which enhances weapon stats. Add DLC1_FrostHide for the base cooking recipe 'Cold Resistance Stew', providing temporary resistance or a slight HP increase. Ensure recipes are only available when DLC is enabled. Update UI to display these recipes in crafting menus with material requirements.",
        "testStrategy": "Unit tests for recipe validation and crafting logic. Integration tests: verify recipes appear in crafting UI when DLC enabled, crafting succeeds with correct materials, and effects (weapon enhancement, resistance/HP boost) are applied correctly.",
        "priority": "medium",
        "dependencies": [
          "108"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "105",
        "title": "Document DLC implementation and create release package",
        "description": "Document the DLC features, create user guides, and assemble the final release package for distribution.",
        "details": "Create documentation for the DLC, including a design document outlining all features (area, materials, recipes, quest, ability, decorations). Write user-facing guides or patch notes. Assemble the DLC package: include all assets (models, textures, sounds), configuration files, and code modules. Ensure the package can be distributed via the game's update system or DLC store. Version the DLC and update the game's manifest or DLC list. Perform a final sanity check before release.\n\nPseudo-code:\n// Package structure\nDLC1_NorthSnowfield/\n  assets/\n  configs/\n  scripts/\n  README.md\n\nUpdate game's DLC registry to include DLC1.",
        "testStrategy": "Verify documentation accuracy against implemented features. Test DLC package installation and activation in a production-like environment. Ensure no missing dependencies or broken references.",
        "priority": "low",
        "dependencies": [
          "100",
          "103"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "106",
        "title": "Add cosmetic decorations for DLC completion",
        "description": "Implement optional decorative elements in the main city, such as an 'Ice Dragon Statue' or achievement display, that appear after DLC completion.",
        "details": "After the Ice Dragon is defeated and the DLC is completed, add cosmetic decorations to the main city. This could be a static model of an Ice Dragon statue placed in a prominent location, or an achievement badge in a UI display. These should have no gameplay impact (no stats or bonuses). Implement as a visual element that appears conditionally based on DLC completion status. Use existing decoration or prop systems if available.\n\nPseudo-code:\nOn DLC completion (boss defeated):\n  if (dlcCompleted) {\n    mainCity.addDecoration('IceDragonStatue', position);\n    achievementUI.showBadge('DLC1_Complete');\n  }",
        "testStrategy": "Visual verification: after completing DLC, check that statue appears in main city and achievement badge is displayed. Ensure no unintended gameplay effects.",
        "priority": "low",
        "dependencies": [
          "109",
          "107"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "107",
        "title": "Implement 'Frost Blessing' global passive ability",
        "description": "Create the global passive ability granted after defeating the Ice Dragon boss, providing a configurable bonus to gathering speed and/or drop rate.",
        "details": "After the Ice Dragon is defeated, grant the player a permanent passive ability 'Frost Blessing'. Provide a configurable bonus (e.g., +X% gathering speed and/or +Y% drop rate). Store the ability state in save data and apply the bonus to global gathering/drop calculations.",
        "testStrategy": "Unit tests for ability application and bonus calculations. Functional test: defeat Ice Dragon, verify ability is granted and active, then test gathering speed increase and drop rate improvement in various scenarios.",
        "priority": "medium",
        "dependencies": [
          "109"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "108",
        "title": "Set up DLC development environment and data structures",
        "description": "Create the foundational data structures and configuration files for the DLC system, including DLC definitions, material definitions, and area definitions.",
        "details": "Implement a DLC configuration system using JSON or a database. Define DLC1 with ID 'DLC1_NorthSnowfield'. Create data structures for new materials (DLC1_IceCrystal, DLC1_FrostHide) with properties like name, type, icon, and description. Define the new area 'North_Snowfield' with metadata (name, description, unlock conditions). Set up a modular system where DLC content can be toggled via a configuration flag or DLC ownership check. Use a game data manager to load DLC definitions at runtime.\n\nPseudo-code:\nclass DLCConfig {\n  string dlcId;\n  string name;\n  bool enabled;\n  Area[] areas;\n  Material[] materials;\n  Recipe[] recipes;\n}\n\nclass Material {\n  string id;\n  string name;\n  string type; // e.g., 'ore', 'hide'\n  string iconPath;\n}\n\nInitialize DLC1 config with materials DLC1_IceCrystal and DLC1_FrostHide.",
        "testStrategy": "Unit tests to verify DLC configuration loading, material definitions are correctly parsed, and area metadata is accessible. Integration test to ensure DLC content is only available when DLC is enabled via a flag or ownership check.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "109",
        "title": "Implement new area 'North_Snowfield' with points of interest",
        "description": "Develop the snowfield area including collection points (Ice Vein, Snow Pine Forest), monster spawns (Snow Wolf, Ice Elemental), and boss encounter (Ice Dragon).",
        "details": "Create the area/scene for North_Snowfield. Place collection nodes for Ice Vein and Snow Pine Forest that yield DLC materials (DLC1_IceCrystal, DLC1_FrostHide). Implement monster spawners for Snow Wolf and Ice Elemental with appropriate loot tables. Design the Ice Dragon boss encounter with unique mechanics and defeat conditions. Ensure the area is only accessible when DLC is enabled and the player has DLC1_MapToken.",
        "testStrategy": "Functional testing: verify area loads correctly when conditions met, collection nodes yield correct materials, monsters spawn and drop loot, boss encounter triggers and can be defeated. Test area remains inaccessible without DLC or map token.",
        "priority": "high",
        "dependencies": [
          "108"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "110",
        "title": "Implement gathering chain integration test",
        "description": "Develop the integration test for the gathering chain: StartGathering -> multiple ticks -> inventory/skill growth -> quest counter increase as per PRD 8.2.1.",
        "details": "Create an integration test class that sets up the gathering system, mocks the necessary services (e.g., Time, DataStore), and simulates the full chain. Use fake implementations for IRng and IClock to control ticks. Verify that inventory increases, skills level up, and quest counters are updated correctly.",
        "testStrategy": "Integration test that runs the full gathering flow and asserts expected outcomes. Use mocked dependencies to isolate the core logic.",
        "priority": "low",
        "dependencies": [
          "124",
          "117",
          "111"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "111",
        "title": "Implement crafting system with material deduction",
        "description": "Develop the crafting logic to check material sufficiency, deduct materials, and add products to inventory as per PRD 8.1.3.",
        "details": "Create a CraftingSystem class with methods to attempt crafting: check if required materials are available in inventory, deduct them if sufficient, and add the crafted item to inventory. Use a data store interface for inventory operations. Example pseudo-code: public class CraftingSystem { public boolean craft(Recipe recipe) { if (!hasMaterials(recipe)) return false; deductMaterials(recipe); addProduct(recipe.getProduct()); return true; } }",
        "testStrategy": "Unit tests covering insufficient materials, exact material matches, and correct inventory updates. Mock the data store to verify calls.",
        "priority": "medium",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "112",
        "title": "Implement save/load system with version migration",
        "description": "Develop the save/load functionality ensuring consistency after save, memory clear, and load, with correct version migration as per PRD 8.2.3.",
        "details": "Create a SaveLoadSystem using IDataStore for persistence. Implement methods to save game state, clear in-memory data, and load it back. Include versioning to handle migration of saved data (e.g., adding missing fields in newer versions). Example pseudo-code: public class SaveLoadSystem { public void save(GameState state) { // Serialize and store } public GameState load() { // Deserialize and apply migration if needed } }",
        "testStrategy": "Unit tests for save and load cycles, verifying state consistency. Test version migration by saving with an old schema and loading with a new one.",
        "priority": "medium",
        "dependencies": [
          "122"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "113",
        "title": "Create comprehensive unit test suite for core logic",
        "description": "Develop a full set of unit tests covering all core logic areas: experience, loot, crafting, and battle systems.",
        "details": "Write detailed unit tests for each core system implemented in tasks 3-6. Ensure tests cover all edge cases and requirements from PRD section 8.1. Use mocking for external dependencies. Aim for high code coverage.",
        "testStrategy": "Run the unit test suite and verify all tests pass. Use coverage tools to identify untested code and add tests as needed.",
        "priority": "high",
        "dependencies": [
          "124",
          "117",
          "111",
          "119"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "114",
        "title": "Implement battle chain integration test",
        "description": "Develop the integration test for the battle chain: StartBattle -> tick loop -> loot drop -> quest completion -> area unlock as per PRD 8.2.2.",
        "details": "Create an integration test that simulates a battle from start to finish. Mock IRng for predictable loot drops and IClock for tick control. After the battle, verify that loot is added to inventory, quests are marked complete, and new areas are unlocked based on game rules.",
        "testStrategy": "Integration test covering the entire battle chain with assertions for each step. Use fake services to ensure deterministic behavior.",
        "priority": "low",
        "dependencies": [
          "117",
          "119"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "115",
        "title": "Final integration and system testing",
        "description": "Perform end-to-end integration testing of the entire system, including all chains and save/load functionality.",
        "details": "Create system tests that simulate real gameplay scenarios: gathering, battling, crafting, and saving/loading. Use fake implementations for all external services to ensure deterministic tests. Verify that all components work together correctly and events are properly handled.",
        "testStrategy": "Run system tests and assert that all integration points function as expected. Check for any regressions or inconsistencies in state management.",
        "priority": "low",
        "dependencies": [
          "110",
          "114",
          "112",
          "116"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "116",
        "title": "Implement UI-Core communication via events",
        "description": "Develop an event system to allow UI to call use cases and Core to push state changes back to UI, avoiding UI logic duplication as per PRD 8.3.2.",
        "details": "Create an event bus or observer pattern. Define events for state changes (e.g., InventoryUpdatedEvent, LevelUpEvent). UI components subscribe to these events and update accordingly. UI actions trigger use case methods in Core. Example pseudo-code: public class EventBus { public void publish(Event event) { // Notify subscribers } }",
        "testStrategy": "Unit tests for event publishing and subscription. Integration tests simulating UI actions and verifying event-driven updates.",
        "priority": "medium",
        "dependencies": [
          "123"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "117",
        "title": "Implement loot drop system with seed-based reproducibility",
        "description": "Develop the loot drop logic with fixed seed for reproducibility and handle weight boundaries as per PRD 8.1.2.",
        "details": "Create a LootDropSystem class that uses IRng for random number generation. Implement a method to roll loot based on weighted items, ensuring that with a fixed seed, the same sequence of drops occurs. Handle edge cases like zero weight or extreme weights. Example pseudo-code: public class LootDropSystem { private IRng rng; public Item rollLoot(List<ItemWeight> items) { // Use rng to select based on weights } }",
        "testStrategy": "Unit tests with fixed seeds to verify reproducibility. Test with various weight distributions, including zero-weight items and boundary conditions.",
        "priority": "medium",
        "dependencies": [
          "122"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "118",
        "title": "Set up CI pipeline for core unit tests",
        "description": "Configure CI to run on every commit: build project, execute core unit tests, and output coverage reports as per PRD 8.4.1.",
        "details": "Extend the CI configuration (e.g., in GitHub Actions) to include steps for building the project, running all unit tests in the core module, and generating a coverage report using tools like JaCoCo. Initially, do not set a coverage threshold.",
        "testStrategy": "Manually trigger the CI pipeline and verify that it runs successfully, tests pass, and coverage reports are generated. Check logs for any failures.",
        "priority": "medium",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "119",
        "title": "Implement battle outcome logic with predictable results",
        "description": "Develop the battle system to determine win/loss based on given attributes within fixed ticks, and handle state damage/decay as per PRD 8.1.4.",
        "details": "Create a BattleSystem class that simulates battles over ticks. Use attributes (e.g., health, attack) to compute outcomes deterministically. Implement state effects like damage over time or decay. Example pseudo-code: public class BattleSystem { public BattleResult simulate(Combatant a, Combatant b, int maxTicks) { for (int tick = 0; tick < maxTicks; tick++) { // Apply damage and state effects } } }",
        "testStrategy": "Unit tests with fixed inputs to ensure predictable wins/losses within tick limits. Test state damage rules and edge cases.",
        "priority": "medium",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "120",
        "title": "Set up project structure and testing framework",
        "description": "Ensure solution/project structure and tests are ready for Godot+C# (xUnit + FluentAssertions + NSubstitute + coverlet.collector) and CI can run on Windows.",
        "details": "Ensure the .NET solution contains Game.Core and unit test projects. Add NuGet packages for FluentAssertions, NSubstitute, and coverlet.collector. Ensure dotnet build and dotnet test run on Windows and scripts/python/quality_gates.py can be used as the unified entry point.",
        "testStrategy": "Verify that the project builds successfully and the test framework runs a simple placeholder test. Ensure the directory structure is correct and dependencies are resolved.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "121",
        "title": "Implement executable build with config packaging",
        "description": "Set up the build process to generate an executable version with base and optional DLC configuration files as per PRD 8.4.2.",
        "details": "Configure Windows export packaging: produce a Godot-exported EXE (and PCK if applicable) and bundle base/DLC configuration files. Prefer scripts/ci/export_windows.ps1 for CI-friendly packaging.",
        "testStrategy": "Run the build and verify that the executable is created with all necessary config files. Test running the executable to ensure it starts without errors.",
        "priority": "low",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "122",
        "title": "Implement Core services interfaces for DI",
        "description": "Define interfaces for Rng, Time, DataStore, and Clock services as per PRD 8.3.1 to enable dependency injection and testability.",
        "details": "Create interfaces in a core package: IRng (for random number generation), ITime (for time-related operations), IDataStore (for data persistence), IClock (for timing/tick operations). These interfaces should abstract the core logic from external dependencies. Example pseudo-code: public interface IRng { int nextInt(int bound); }",
        "testStrategy": "Write unit tests that verify the interfaces can be implemented and mocked. Use NSubstitute to create fake implementations for testing.",
        "priority": "high",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "123",
        "title": "Set up dependency injection framework",
        "description": "Set up manual dependency injection (composition root) to inject Core services as per PRD 8.3.1.",
        "details": "Implement manual dependency injection to provide implementations of IRng, ITime, IDataStore, IClock to core systems. Ensure that in tests, these can be replaced with fake implementations. Use an explicit composition root / factory that wires adapters to Core ports.",
        "testStrategy": "Write a test that verifies DI works correctly by injecting a fake service and asserting its use in core logic.",
        "priority": "high",
        "dependencies": [
          "122"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "124",
        "title": "Implement experience and level system logic",
        "description": "Develop the core logic for experience thresholds, level-up triggers, and unlock condition checks as per PRD 8.1.1.",
        "details": "Create a class ExperienceSystem with methods to add experience, check if level up is triggered based on thresholds, and handle unlock conditions. Use a data structure like a map for level thresholds. Example pseudo-code: public class ExperienceSystem { private int currentExp; private int currentLevel; public void addExp(int amount) { currentExp += amount; while (currentExp >= getThresholdForLevel(currentLevel+1)) { levelUp(); } } }",
        "testStrategy": "Write unit tests covering edge cases: exact threshold matches, multiple level-ups, unlock conditions. Use fixed inputs to ensure predictable outcomes.",
        "priority": "high",
        "dependencies": [
          "120"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "125",
        "title": "Implement DlcManager and DLC Content Integration",
        "description": "Set up DLC management system to handle DLC regions, content, and integration with main game.",
        "details": "DlcManager loads DLC manifests (JSON/data files) to enable DLC content. Implement DLC regions: locked state with prompt, unlockable. Include at least 1 gathering point, 1 enemy type, and 1 quest chain entry in DLC. Ensure DLC materials can be used in \u22651 main world recipe or enhancement (resource feedback). DLC milestones grant \u22651 global passive or main-world usable equipment (ability feedback).\n\nPseudo-code:\nclass DlcManager {\n  LoadDlc(manifestPath);\n  IsDlcEnabled(dlcId) -> bool;\n  GetDlcContent(dlcId) -> DlcData;\n}\n// DlcData includes regions, items, recipes, passives.",
        "testStrategy": "Unit tests for DLC loading and enabling. Integration tests to verify DLC content appears in game and feedback mechanisms work (resources and abilities).",
        "priority": "medium",
        "dependencies": [
          "127",
          "128"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "126",
        "title": "Implement Core Unit Tests and Final Integration",
        "description": "Write comprehensive unit tests for core systems and perform integration testing to ensure full game loop works.",
        "details": "Create unit tests for core systems as specified: experience formulas, drop rolls, crafting material deduction, combat victory/defeat determination. Integrate all systems and test the full game loop: new game -> gather/craft/combat -> growth -> unlock region -> defeat boss -> stage settlement -> continue. Test DLC integration and feedback loops. Ensure offline reward calculation works correctly.",
        "testStrategy": "Automated unit tests using xUnit (+ FluentAssertions). Integration tests simulate player actions and verify expected outcomes. Manual testing for UI and gameplay feel; GdUnit4 smoke tests where engine behavior is involved.",
        "priority": "medium",
        "dependencies": [
          "129",
          "127",
          "130",
          "128",
          "125"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "127",
        "title": "Implement InventoryManager and CraftingManager",
        "description": "Set up inventory system for item management and crafting system for recipe-based item creation.",
        "details": "InventoryManager handles player inventory with items, quantities, and capacity. CraftingManager manages recipes: check materials, consume them, and produce items. Include at least 1 crafting skill with \u22655 recipes. Integrate with SkillManager for crafting skill progression.\n\nPseudo-code:\nclass InventoryManager {\n  List<ItemSlot> items;\n  AddItem(item, quantity);\n  RemoveItem(item, quantity);\n}\nclass CraftingManager {\n  List<Recipe> recipes;\n  Craft(recipeId, player) -> bool;\n}",
        "testStrategy": "Unit tests for inventory add/remove operations. Test crafting with sufficient/insufficient materials. Verify recipe outcomes and skill exp gain.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "128",
        "title": "Implement MapManager and RegionUnlocks",
        "description": "Create map system to manage regions and unlock new areas based on combat/tasks/skill thresholds.",
        "details": "MapManager tracks available and locked regions. RegionUnlocks handles conditions to unlock new areas (e.g., defeat Boss, complete task, reach skill level). Ensure at least 1 new region can be unlocked via these means. Integrate with GameState for persistence.\n\nPseudo-code:\nclass MapManager {\n  List<Region> regions;\n  UnlockRegion(regionId);\n}\nclass RegionUnlocks {\n  CheckUnlockConditions(player) -> List<Region>;\n}",
        "testStrategy": "Unit tests for unlock condition checking. Integration tests to verify region unlocking updates GameState and UI.",
        "priority": "medium",
        "dependencies": [
          "129"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "129",
        "title": "Implement EventBus for System Communication",
        "description": "Set up an event bus to handle communication between game systems (e.g., skill updates, combat events).",
        "details": "Create an EventBus class using observer pattern or pub/sub. Define event types (e.g., SkillLevelUp, ItemCrafted, EnemyDefeated). Systems can subscribe to and publish events. Ensure it's lightweight and thread-safe if needed.\n\nPseudo-code:\nclass EventBus {\n  Dictionary<EventType, List<Action<EventData>>> subscribers;\n  Subscribe(EventType, Action<EventData>);\n  Publish(EventType, EventData);\n}",
        "testStrategy": "Unit tests for event subscription and publishing. Integration tests to verify systems communicate correctly via events.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      },
      {
        "id": "130",
        "title": "Implement LootGenerator and Combat Rewards",
        "description": "Set up loot generation system for enemy drops and combat rewards, including stage Boss drops.",
        "details": "LootGenerator uses RngService to roll for drops based on enemy loot tables. Integrate with InventoryManager to add loot to player inventory. Ensure Boss defeat gives appropriate rewards and triggers stage settlement. Include drop tables for all enemies and the Boss.\n\nPseudo-code:\nclass LootGenerator {\n  GenerateLoot(enemyType, playerLuck) -> List<Item>;\n}\n// Called on combat victory\nRewardPlayer(player, loot);",
        "testStrategy": "Unit tests for loot generation with fixed seeds to verify drop rates. Integration tests to ensure loot is added to inventory after combat.",
        "priority": "medium",
        "dependencies": [
          "127"
        ],
        "status": "pending",
        "subtasks": [],
        "adrRefs": [],
        "archRefs": [],
        "overlay": "",
        "complexity": 0,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": null
      }
    ],
    "metadata": {
      "version": "",
      "description": "",
      "created": "",
      "updated": "",
      "lastModified": "",
      "taskCount": 130,
      "completedCount": 0,
      "tags": [
        "master"
      ]
    }
  }
}
